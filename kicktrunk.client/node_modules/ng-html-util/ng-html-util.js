/**
 * Append the 'px' suffix to the input value.
 * @param {?} value
 * @return {?}
 */
function convertNumberToPx(value) {
    return value + 'px';
}
/**
 * Remove the 'px' suffix from the input value.
 * @param {?} value
 * @return {?}
 */
function convertPxToNumber(value) {
    if (!value)
        return 0;
    return Number.parseInt(value.replace('px', ''));
}

/**
 * Calculate the top left position of the targetElement
 * @param {?} document
 * @param {?} targetElement
 * @return {?}
 */
function extractElementPosition(document, targetElement) {
    let /** @type {?} */ body = document.body;
    let /** @type {?} */ docEl = document.documentElement;
    let /** @type {?} */ windowPageYOffset = document.defaultView && document.defaultView.pageYOffset || undefined;
    let /** @type {?} */ windowPageXOffset = document.defaultView && document.defaultView.pageXOffset || undefined;
    let /** @type {?} */ scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;
    let /** @type {?} */ scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;
    let /** @type {?} */ clientTop = docEl.clientTop || body.clientTop || 0;
    let /** @type {?} */ clientLeft = docEl.clientLeft || body.clientLeft || 0;
    if (!targetElement) {
        // No element found, so return the current position to not cause any change in scroll position
        return { top: scrollTop, left: scrollLeft };
    }
    let /** @type {?} */ box = targetElement.getBoundingClientRect();
    let /** @type {?} */ top = box.top + scrollTop - clientTop;
    let /** @type {?} */ left = box.left + scrollLeft - clientLeft;
    return { top: Math.round(top), left: Math.round(left) };
}

/**
 * Generated bundle index. Do not edit.
 */

export { convertNumberToPx, convertPxToNumber, extractElementPosition };
